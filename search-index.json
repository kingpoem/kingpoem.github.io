[{"title":"archlinux 常用配置介绍","date":"2025-09-21T08:47:17.000Z","url":"/posts/beautify/","categories":[["undefined",""]],"content":"主要讲解安装完后的 archlinux 各种点文件。 管理点文件这是一个令人相当头疼的问题，我曾写过一个点文件的管理器，但是相当依赖我自己的配置，而且点文件变化很大，管理起来太费心费力，几乎没怎么用就废弃了那个点文件管理器。后面发现了 chezmoi 这个工具，它有很多优点，但是，用它来管理各种各样的点文件依旧费心费力。所以，我采取了只是备份的方案，只要 chezmoi 上传我的一台电脑的配置到 github 即可。多余的什么模板文件统统不需要。在传给其他电脑时，只用复制粘贴即可。虽然这个方法看上去简陋，但我认为相比于所谓的“智能化”管理都要方便。而且，因为刚开始使用 archlinux 的时候经常重装，所有配置尽量使用一些默认的方案。"},{"title":"archlinux 安装命令自用一览","date":"2025-09-21T06:22:17.000Z","url":"/posts/archlinux/","tags":[["archlinux","/tags/archlinux/"]],"categories":[["undefined",""]],"content":"因为经常需要装系统，故将我的 archlinux 安装过程中的命令列在此。新手请勿使用。 参考教程：archlinux 简明安装 安装准备ventoy 如果原有 windows 是专业版，记得先记录 bitlocker 恢复密钥。关闭 bitlocker 在 meta 键后搜索 bitlocker 即可。 家庭版没有 bitlocker。 然后都要在 bios 里关闭安全启动（如果没有关闭 bitlocker，此时会要求输入恢复密钥） wifi 连接使用手机热点（确保是英文），只建议使用热点，不使用校园网或者路由器 第一阶段 第二阶段 第三阶段现在默认是 wayland 如果使用 Wayland，在「系统设置 - 输入设备 - 虚拟键盘」中选中 Fcitx 5 打开 System Settings &gt; Language and Regional Settings &gt; 在 Language 中点击 Add languages… &gt; 选择中文加入 ADD，再拖拽到第一位 &gt; 点击 Apply 打开 系统设置 &gt; 区域设置 &gt; 输入法 点击提示信息中的 运行 Fcitx 点击 添加输入法 &gt; 找到简体中文下的 Pinyin &gt; 点击 添加 即可加入拼音输入法（现在默认有） 第四阶段急救地址 intel 核显 nvidia 少女祈祷中… 第五阶段截图使用 spectacle 第六阶段常见配置见下一篇 常用急救包 archwiki cn 拯救滚挂的Arch Linux sudo mkinicpio -P or sudo pacman -S linux journalctl -b or sudo dmesg grep -E &quot;installed|upgraded&quot; /var/log/pacman.log journalctl cheat sheet chroot要安装东西先连接网络 "},{"title":"使用 chezomi 管理你的 dotfiles","date":"2025-06-01T05:38:44.000Z","url":"/posts/chezmoi/","tags":[["chezmoi dotfiles","/tags/chezmoi-dotfiles/"]],"categories":[["undefined",""]],"content":"前言在许久之前自己手写了一个 dotfiles 的管理工具，但在开发的过程中还是遇到了不少问题，最后还是只能在自己的机器上复现，在其他人的机器上还不如直接复制粘贴来的方便。最近发现了这个 chezmoi 工具，它可以很方便的管理你的 dotfiles，解决了跨平台与兼容性、敏感数据安全、多设备配置同步与管理和模板与自动化问题。这里来推广一下并给出一份入门级使用教程。 注意：如果你想使用这个工具，请一定提前备份已有的 dotfiles，以免因为刚上手时不清楚命令的具体运作方式导致备份丢失。 chezmoi 会在你自己的机器上新建一个 ~/.local/share/chezmoi 目录，你可以往这个目录里手动添加你需要它管理的配置文件，然后 chezmoi 会将你原来的配置文件复制并改名为以 dot_xxx 形式的文件到这个新目录下，接着就可以通过 github 平台来管理这个新目录。除了 dot_xxx 形式的文件外，还可以创建 run_xxx 等形式的文件来存储跨平台用的脚本。 快速上手初始化 添加命令更完整的添加命令： ~&#x2F;.config&#x2F;chezmoi&#x2F;chezmoi.toml使用 chezmoi edit-config 命令可以自动打开并编辑 chezmoi 的配置文件我习惯所有修改配置文件的命令都是该程序名后面加个 calias chezmoic=&quot;chezmoi edit-config&quot; 更换编辑器更改 chezmoi 默认编辑器为 nvim: 在 ~/.config/chezmoi/chezmoi.toml 中添加以下内容： 更改配置文件并应用 为了便于平常更改，我在 ~/.zshrc 中添加了以下内容： 查看更改 比较本地的两个配置文件之间的差异 ~/.config/chezmoi/chezmoi.toml 配置文件这个配置文件可以配置chezmoi自身的一些行为，这里提供我的一份简单配置： 值得注意的是，chezmoi 不允许添加自己的配置文件管理，也就是说这份 toml 文件是无法 chezmoi add 的。 模板chezmoi 解决在多台机器上管理配置文件的方案是使用模板。模板里会留有一些变量，在不同机器上会根据机器的自身特性来动态替换这些变量。 以添加 ~/.gitconfig 为例 在其他设备上初始化时，可以使用如下命令： 上传加密文件 参考chezmoi 官方文档Hank 的博客初等記憶體的博客chezmoi 作者自己的点文件 "},{"title":"爬B工程及 Python 导包机制","date":"2025-05-03T14:57:47.000Z","url":"/posts/bvget/","categories":[["undefined",""]],"content":" 前言：本文使用 uv 进行 Python 环境管理，简述爬取B站视频的核心要点，打包爬取B站视频的命令行工具，并上传至 PyPI，然后自己安装使用针对 Python 的导包机制由浅入深进行讲解，给出七个针对性问题及解答，在文末提出推荐解决方案 Python 环境管理的几种方案Python 环境管理有多种方案，在数据科学、机器学习方面，我们一般都会使用 conda。但是由于它的体积过于庞大，有时我们只是想要一个可以跑小项目的 Python 环境，venv 也不失为一个不错的选择。poetry 和 Hatch 也可以用来管理 Python 环境。现在还有用 Rust 编写的 uv。 基于 AI 生成的比较几种 Python 环境管理工具的优缺点整理（2025-1-31）： pip：生态齐全。但解析依赖不稳定，无 lock 文件。 poetry：速度较慢，解析基于 toml 文件，支持 poetry.lock 文件，内置 venv 管理，支持发布到 poetry publish，更适合项目管理和发布 Python 包。 uv：速度最快，基于 Rust，支持 pyproject.toml 和 requirements.txt 文件，不支持 pip install 以外的高级功能，可以创建虚拟环境，但不支持发布 PyPI（可以借助其他工具实现），没有 lock 文件。如果只想快速安装和管理 Python 依赖，不需要复杂功能，可以在小项目里使用。 Hatch：支持依赖管理、虚拟环境、多环境管理、版本控制和PyPI 发布。它的设计目标是比 Poetry 更快、更灵活，适用于复杂项目、自动化任务和 CI&#x2F;CD 环境。 爬取 B 工程视频选用 lxml 而不是 BeautifulSoup 的理由 lxml 支持 XPath 语法, 而 BeautifulSoup 不支持 lxml 要求所爬取的数据结构规范，所有标签闭合，而 BeautifulSoup 则不一定 lxml 的解析方式为直接基于 ElementTree 解析，而 BeautifulSoup 则是以 Python 对象方式操作 lxml.html.fromstring() 和 BeautifulSoup 同样支持 cssselect，不需要另外安装 cssselect 库 简述 XPath XML 和 HTML 都是一种标记语言而不是编程语言 XML 用于存储、传输数据，而 HTML 专门用于展示网页内容，HTML 文档也叫做网页，HTML 相当于基于 XML 的规范衍生出的一套标记语言，XML 更加通用 XML 语法严格（要求标签必须闭合，区分大小写），而 HTML 语法松散（标签可以不闭合，不区分大小写） XPath 是一门在 XML 文档中定位元素的语言 给出一些常用的 XPath 表达式： lxml.html 和 lxml.etree.HTML 的区别两种方法都可以用于解析 HTML，但是 lxml.html 具有自动修正 HTML 结构的特点，返回 lxml.html.HtmlElement 对象，比 ElementTree 提供更多 HTML 相关功能，因此更加适用于网页爬取。 数据分析–单个视频中的 playinfo 信息B站大多单个视频在 开发者工具-&gt;Network-&gt;刷新后的第一条信息（对视频播放信息的请求）-&gt;Response 中 html-&gt;head-&gt;第四个script中保存了 window.playinfo 信息，其中包含了视频播放所需的详细信息。在 data-&gt;dash-&gt;video&#x2F;audio 中分别保存了视频和音频的储存地址，包括 baseUrl,base_url,backupUrl(2个),backup_url(2个) 将 bvget 命令写入系统路径可以手动添加到系统路径中：sudo mv bvget.py /usr/local/bin/bvget 也可以使用 setup.py 进行安装 但是从 PEP 518 开始就有了 pyproject.toml 文件，提供了一个更加现代化、声明式的项目配置 下面提供一个使用 uv 构建的简单的示例： 对以上内容的解读： [project] 定义了项目的基本信息，包括名称、版本、描述、作者、readme等[build-system] 定义构建系统[project.scripts] 定义了项目的命令行工具，这里定义了一个名为 bvget 的命令，对应 bvget.py 中的 main() 函数 在项目根目录执行： 构建完成后，dist 目录下会生成一个 .whl 文件，.whl 文件是可安装的 Python 包，可以直接使用 pip 安装。.tar.gz 文件是源码包，可以用于源码安装。 上传至 PyPIuv 不支持直接发布 Python 包到 PyPI，但可以借助 twine 工具来实现。首先需要注册一个 PyPI 账户，然后在项目根目录下执行： 之后你就可以在任何 Python 环境中安装 bvget 了： Python 导包机制 提醒：环境为 Arch Linux + VSCodePycharm 有自己的想法（听说是会帮你自动添加路径，如果项目上线就会报各种导入失败的错误）且我没怎么用过，故本文不做讨论为方便后续查看 sys.path 内容，建议添加 from rich import print 来增强可读性所有代码执行的根目录为 project 相关概念 package：包，一个包含模块的目录，包含 __init__.py 文件，可以包含子目录 module：模块，一个 .py 文件，包含 Python 代码 __name__：当前模块名称（此项与后面解释息息相关） __package__：当前模块所在的包名称（此项与后面解释息息相关） sys.path：模块搜索路径列表，也即绝对导入搜索路径 __init__.py：模块的初始化文件，在导入包时，会自动执行该文件 __path__：当前模块的搜索路径 __file__：当前模块的文件路径 __loader__：模块的加载器，指向加载该模块的加载器对象 __spec__：存储模块的导入信息（PEP 451） PEP：Python enhancement proposal，Python 增强建议，是 Python 社区提出的一些改进建议 top-level package：所执行的 package 中最高的一层 问题场景有如下目录结构： 每个文件中均有一个 _fun() 函数。相对导入基准路径为当前模块所在包。比如 C.py 的基准路径是 sub1，A.py 的基准路径是 project。import ..A 这样的隐式相对导入已被 PEP 328 禁止，后文所说的相对导入均指的是显式相对导入。 问题一：python filename.py 和 python -m modulename 的区别 命令1：python sub1&#x2F;C.py 命令2：python -m sub1.C 补充说明： VSCode 里直接点击小三角运行 Python 文件同命令1原理 命令2由 PEP 338 规定 把这个问题放在第一个是为了让读者知道作者是如何运行 Python 文件的，关于命令执行结果的区别，将在问题三中说明 后文为简化，类似于命令1中的操作均称呼为”命令1”，类似于命令2中的操作均称呼为”命令2” 在 C.py 中有如下代码： 命令1执行结果： 命令2执行结果： 第一个输出发现我在 VSCode 中项目根目录是 project，而命令1 sys.path 里的路径只有 sub1 目录 第二个输出表明 C.py 作为顶级脚本被加载，name 的值为 main，顶级脚本会失去正常名称，而被改为 main 第三个输出 package 不是当前模块所在的包名称吗？为什么它的值会是 None 呢 疑惑将在问题三得到解答 问题二：if name &#x3D;&#x3D; ‘main‘: 语句的作用是什么加载 Python 文件有两种方式：作为顶级脚本（一次只能有一个）或者作为模块。 作为顶级脚本：直接运行 python filename.py 或者 python -m modulename，会将该文件作为顶级脚本加载 作为模块：当在其他文件中遇到 import 语句时，它会作为模块加载在 C.py 中有如下代码： 执行 python .&#x2F;sub1&#x2F;C.py 或者 python -m sub1.C 输出结果： 接着我们保留 C.py 中代码，C.py 中依然有 if name &#x3D;&#x3D; “main“: 语句，我们在 A.py 中导入 C.py 在 A.py 中有如下代码： 执行 python .&#x2F;A.py 或者 python -m A 输出结果在最后一行略有不同： 从输出中可以看出 C.py 中的 if name &#x3D;&#x3D; “main“: 语句未被执行，name 的值为 sub1.C。 所以问题二的答案：if name &#x3D;&#x3D; ‘main‘: 语句的作用是只有当该模块作为顶级脚本时才会执行后面的语句，如果该模块是被 import 进来的，则不会执行。 问题三：如何在 B.py 中导入 A.py 对上面错误做法原因分析：相对导入使用模块的名称（即 name）来确定它在包层次结构中的位置。当你使用相对导入时，如 from .. import A，点表示在 package 层次结构中增加一些级别。如果当前模块名称是 project.sub1.C，则 ..A 表示 project.A。要使 from .. import 正常工作，模块名称必须至少包含 import 语句中的点数。 但是，如果模块名称是 main，它的名称里没有点，就好像该模块是顶级模块一样，不管该模块在文件系统上的实际位置如何，其都没有更往上一层的包，因此不能在里面使用 from . import A 这种相对导入。 理解了问题三错误做法错误的原因，我们再回看问题一。 命令1执行结果： 命令2执行结果： 从 Python 2.6 开始，用于包解析目的的模块的名称不仅由其 name 属性决定，还由 package 属性决定。模块的名称实际上是 package + ‘.’ + name，如果 package 是 None，则只是__name__。根据对问题三错误做法的分析，我们知道，两种命令都会让 C.py 作为顶级脚本被加载，这样的话都无法识别上层包，之所以命令2的 package 值为 sub1，是因为命令中有 sub1.C 告诉了 Python 加载 C.py 所在的包 sub1。 问题四：如何在 C.py 中导入 A.py常见于 sub1 目录为一个 test 目录以下问题解决办法均只展示部分 问题五：如何在 D.py 中导入 C.py 问题六：如何在 E.py 中导入 D.py 问题七：init.py 文件的作用是什么__init__.py 文件是 Python 包的初始化文件，它会在包被导入时自动执行。但自从 PEP 420 开始（即 Python 3.3），一个目录不需要 __init__.py 文件也可以自动成为包。也就是说一般情况下加不加 __init__.py 文件无所谓。 推荐使用方式通过 sys.path.append() 的方式可以解决燃眉之急，但这种做法并不在大型项目中推荐，因为它会导致项目的依赖关系变得复杂，且不利于代码的维护。同理，使用环境变量 PYTHONPATH 来指定搜索路径也是相当于手动修改 sys.path，也不推荐。 以下是几种替代方案： 可编辑安装：setuptools + editable install在 project 下创建 setup.py 文件，内容如下： 运行：pip install -e . 或者使用 uv 进行可编辑安装，进入 project 目录（要求底下有 setup.py 文件或者 pyproject.toml 文件），执行：uv pip install -e .。 .pth 文件：Python 在启动时会自动读取 site-packages 目录下的 .pth 文件，并将其中的路径添加到 sys.path 安装为包：将自定义模块打包并安装到 Python 环境中，使其可以被直接导入，该方法在 bvget 项目中已经提供具体做法 参考清华酒井24爬虫讲义StackOverflow 上关于相对导入的讨论 "},{"title":"Gentoo 安装记录","date":"2025-05-03T14:29:24.000Z","url":"/posts/gentoo/","categories":[["undefined",""]],"content":"关于 Gentoo Linux 的安装 &amp;&amp; 选择正确的安装媒介 为避免双系统读取 RTC 时间因为时区不一致导致无法加载 Gentoo 内核问题，在 Windows 端设置写入到 RTC 的时区为 UTC：sudo reg add &quot;HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\TimeZoneInformation&quot; /v RealTimeIsUniversal /d 1 /t REG_DWORD /f 关闭 bit locker 加密和 secure boot 在选择 gentoo 的 boot in normal mode 安装时，会直接进入 grub rescue 环境，退出后再进入 Windows 则显示”你的PIN不可用，单击以重新设置PIN” 选择 boot in grub2 mode passwd root如果有公网IP，则设置一个强密码 rc-service sshd start 启动ssh服务 配置网络 net-setup显示enp12s0（以太网接口）和wlp0s20f3（无线局域网） 接口命名规则： p表示设备连接到主板的第几号PCI总线 s表示设备在第几号插槽 f表示该插槽的功能编号为几 注意连接协议类型： open/wep表示开放或者等效有线保密（由于安全性低，现已废弃） 推荐使用wpa-psk/wpa2-psk ip link set wlp0s20f3 up显示RFNETLINK answers: Operation not possible due to RF-kill 需要rfkill unblock wifi 默认dpcp服务没有启动，需要echo &#39;config_eth-=(&quot;dhcp&quot;)&#39; &gt;&gt; /etc/conf.d/net，修改后，重启网络服务/etc/init.d/network restart ip addr查看本机ip地址，我的是连接无线的，则是wlp0s20f3项inet（表示IPV4协议）后 192.168.43.57/24去掉/24（表示网络部分占用前24位，子网掩码为255.255.255.0） 在另一台处于同一个局域网（热点）的电脑远程连接ssh root@192.168.43.57后出现提示输入yes，再输入刚才设置的root密码 如果你在接下来的安装中，不小心断开了连接，重新连接继续之前的操作即可 ，注意服务器的ip地址可能会发生变化如果你的 ssh 卡住，可以ps aux | grep ssh 查找进程 PID 并使用 kill -9 PID 杀掉这个 ssh 进程，再重新连接 准备磁盘磁盘分区 lsblk -f显示有sda nvme0n1 nvme1n1分别对应U盘，加装的固态硬盘，原装的固态硬盘 fdisk /dev/nvme0n1 g创建一个新的GPT磁盘分区表GUID: AEE90FFF-915C-471C-BF7D-4CB8CD08E2D n创建一个新的分区，按2次enter选择默认的分区号，和分区开始位置，结束位置设置为+1G，如果有显示Do you want to remove the signature则输入yes，t更改磁盘类型为efi 接下来同样操作建立32G的swap分区 创建/分区，我分配了300G 创建/home分区，分配剩下所有空间，文件系统和根分区皆为默认的 Linux filesystem 创建文件系统 挂载分区 如果分错了，可以umount /mnt/gentoo/home，中途随时可以使用lsblk -f或者fdisk -l来查看分区状况 安装Gentoo基础系统 vi /mnt/gentoo/etc/portage/make.conf中COMMON_FLAGS改为-march=native -O2 -pipe增加配置如下： 上文配置解读：指定12线程并行编译，1job对应内存2G指定 Gentoo 软件包的镜像源USE 标志用于控制软件包的编译选项，-gtk 意为禁用 GTK 支持，vulkan 为图形 API 支持，dist-kernel 为启用分布式内核（Gentoo 提供的预编译内核），dbus 用于进程间通信指定系统使用显卡驱动VIDEO_CARDS指定系统可以接受的软件许可协议设置接受的软件本地化语言指定 GRUB 引导程序的平台目标 设置时区 查看可用时区：ls /usr/share/zoneinfo/...OpenRC： echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone emerge --config sys-libs/timezone-datasystemd： ln -sf ../usr/share/zoneinfo/Europe/Brussels /etc/localtime之后当 systemd 运行时，时区和相关设置可以使用 timedatectl 命令设置 emerge vim 我不希望使用nano vim /etc/locale.gen 生成区域设置添加如下： locale-gen 根据 /etc/locale.gen 文件中的设置生成所需的语言环境 locale -a 可以验证当前所选择的 locale 可用 eselect locale list 显示可用目标 eselect locale set 5 选择 zh_CN.utf8 env-update &amp;&amp; source /etc/profile &amp;&amp; export PS1=&quot;(chroot) $&#123;PS1&#125;&quot; 重新加载环境 nano 检测目前语言设置情况 配置内核 配置系统 安装系统工具 配置引导加载程序 收尾安装工作 故障 问题描述：前期下载用了 OpenRC，Gentoo 启动卡死在了 Setting system clock using the hardware clock [UTC] ... 按任何键都无反应。 问题排查： 进入 BIOS 界面，查看系统时间为北京时间 进入修复环境 mount /dev/nvme1n1p3 /mnt arch-chroot /mnt hwclock --verbose 查看硬件时钟为 UTC 时间，但数值却为 CST 时间 回顾设置时区部分，执行 emerge --config sys-libs/timezone-data 时，显示 Assuming your /etc/localtime symlink is what you want; skipping update 问题更大：硬件时间应该是一台电脑只有一个，而系统时间应该可以有多个 在 Arch 中 timedatectl set-ntp true 启动 System clock synchronized 不对啊，这是在内存中进行的 进入修复环境 ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime hwclock --systohc hwclock --verbose 检查硬件时钟正常 reboot 显示问题更大换 systemd 吧 "},{"title":"Windows 更新的链式反应","date":"2025-05-03T14:06:14.000Z","url":"/posts/new-blog-md/","categories":[["undefined",""]],"content":"Windows 更新干掉了自己2024年11月22日，就在我开心使用 Arch+Win11 双系统的时候，一次 Windows 重启更新后，又抽搐般的反复重启了几次。当在 grub 界面选择 Windows 作为启动项时，屏幕上赫然显现下面2行字： 然后就再也进去不 Windows 了。 我执行了 grub-mkconfig -o /boot/grub/grub.cfg 后，Windows 连在 grub 界面都不显示了。后来找人帮忙，暂时解决了问题。然后，第二天，Windows 又更新了。于是我循着前辈的足迹，又暂时解决了问题。 首先说明一下我整个的电脑环境： 华为电脑 单盘（1T，无法加装硬盘，磁盘分区按先后顺序为 efi1+C+D+E+boot+efi2+&#x2F;+recovery1+recovery2+recovery3 ） 双系统（Win11 + Arch） 注意这里的2个 efi 分区，第一个是 Windows 的，第二个是 Arch 的，grub 装在了 efi2 里，后面3个 recovery 是 Windows 的恢复分区，一般来说新电脑会有1个，其他的是 Windows 自己系统升级的产物，真正在工作的只有1个。较新的分区一般会位于磁盘的后部（更高的扇区），原厂或系统安装的分区通常在磁盘的前部（可以通过在 powershell 中使用reagentc &#x2F;info查看当前使用的是哪个恢复分区）。 通过 efibootmgr 查看 efi 的启动顺序，会发现没有 Windows 的引导，所以可以自己手动创建一条 Windows 的引导，然后通过 efibootmgr -o 可以自定义启动顺序。 常用命令备忘： efi 文件在 Arch 中的参考路径：/boot/EFI/ARCH/grubx64.efi Windows 更新干掉了 Arch 和自己对于 Arch 的存在，Windows 是不能够容忍的。在第一阶段，他自己更新把自己干掉了，在第二阶段，他更新的攻击目标转向了 Arch。他将 Arch 的引导从 grub 里删除了，无论怎么启动都会是 Windows。刚开始，我通过 UEFI 界面的调节还能暂时解决问题。 到后来，我在 UEFI 中设置 Windows 先，会直接进入 grub 的修复环境，桌面显示如下文字： 修复步骤： 但是，在 grub 界面，如果选择 Windows，又会显示找不到 efi，选择 Arch 则可以正常进入。 如果我在 UEFI 中设置 Arch 先，那么会直接进入 Windows。 也就是说，Arch 在用原本应该是 Windows 的 efi，Windows 在用原本是 Arch 的 efi！ 那么为什么 Arch 能用 Windows 的 efi，答案就是不能用，所以会显示 unknown filesystem，要通过在 grub 的修复环境中选择 Arch 的 efi 才能进去。 毁灭与新生于是，重装系统！ 刚开始还是想挑战高难度一点的 Gentoo 的，但是由于挂载的问题，第一次安装失败 。万念俱灰之下，又迫切需要一台能用的电脑，于是选择了单系统 Arch。还是 Arch 最平衡，不像 Gentoo 那样安装时间要特别长，又不像 deepin 和 Ubuntu 那样安装特别简单。 重装系统能解决许多历史遗留问题，但由于没有做好备份工作（主要是某些文件在项目中需要加入 .gitignore，在使用 Github 进行备份时就没有包含进去，包括项目中的 csv 原始数据，博客的 themes&#x2F;butterfly 下的配置文件，按道理说这个目录下的配置文件应该放在博客根目录下，但是为什么我没有呢？也是历史遗留问题！），我丢失了很多东西。因为丢失了博客的配置文件，而我又不想再花大把时间进行博客的配置，于是新开了这个博客，并选择了一套开箱即用的主题，并调整了一下自己写作博客的思路。我想主要以文字为主（图片的路径问题在 butterfly 下也已经恼到我了，而且图片多了的话博客加载速度也慢），人类原创，融入英文写作。 但是我还是需要 Windows 的，正值数学实验和金工实习期间，需要 Matlab 和 3D打印的一些建模和打印软件（SolidWorks 和 Wiiboox，这俩玩意也是异常的难安装），这些在 Arch 下都没有什么特别好的替代品，只能选择在 Oracle VirtualBox 中创建一个 Win11 的虚拟机（Matlab用网页版）。中间还出了一个小问题，因为在选择新建电脑时选择了自动安装，导致没有超级管理员，后面无论是从浏览器还是从应用商店里下载的QQ或者微信都无法安装，当然，终端管理员也无法打开。解决方法就是重装，新建电脑时不要选择自动安装。 新建博客在看了各种博客框架后，我依然选择了 Hexo，并解决了包括 npm 全局安装导致的 root 权限等一系列历史遗留问题。 "},{"date":"2025-05-03T16:18:11.889Z","url":"/friends/index.html","categories":[["undefined",""]],"content":" 清风之恋の小窝 ええ...?被找到了呢,这里会不定期更新一些好玩的东西哦 Echo 的自留地 这里是 Echo 的自留地, 记录一些生活中的点滴 冷雨的博客 希望能成为一个厉害的人 "}]