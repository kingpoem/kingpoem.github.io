<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kingpoem&#39;s blog</title>
  
  
  <link href="https://kingpoem.github.io/atom.xml" rel="self"/>
  
  <link href="https://kingpoem.github.io/"/>
  <updated>2025-05-03T15:14:05.028Z</updated>
  <id>https://kingpoem.github.io/</id>
  
  <author>
    <name>kingpoem</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>爬B工程及 Python 导包机制</title>
    <link href="https://kingpoem.github.io/posts/bvget/"/>
    <id>https://kingpoem.github.io/posts/bvget/</id>
    <published>2025-05-03T14:57:47.000Z</published>
    <updated>2025-05-03T15:14:05.028Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：本文使用 uv 进行 Python 环境管理，简述爬取B站视频的核心要点，打包爬取B站视频的命令行工具，并上传至 PyPI，然后自己安装使用<br>针对 Python 的导包机制由浅入深进行讲解，给出七个针对性问题及解答，在文末提出推荐解决方案</p></blockquote><h3 id="Python-环境管理的几种方案"><a href="#Python-环境管理的几种方案" class="headerlink" title="Python 环境管理的几种方案"></a>Python 环境管理的几种方案</h3><p>Python 环境管理有多种方案，在数据科学、机器学习方面，我们一般都会使用 conda。但是由于它的体积过于庞大，有时我们只是想要一个可以跑小项目的 Python 环境，venv 也不失为一个不错的选择。poetry 和 Hatch 也可以用来管理 Python 环境。现在还有用 Rust 编写的 uv。</p><p>基于 AI 生成的比较几种 Python 环境管理工具的优缺点整理（2025-1-31）：</p><ol><li>pip：生态齐全。但解析依赖不稳定，无 lock 文件。</li><li>poetry：速度较慢，解析基于 toml 文件，支持 poetry.lock 文件，内置 venv 管理，支持发布到 poetry publish，更适合项目管理和发布 Python 包。</li><li>uv：速度最快，基于 Rust，支持 pyproject.toml 和 requirements.txt 文件，不支持 pip install 以外的高级功能，可以创建虚拟环境，但不支持发布 PyPI（可以借助其他工具实现），没有 lock 文件。如果只想快速安装和管理 Python 依赖，不需要复杂功能，可以在小项目里使用。</li><li>Hatch：支持依赖管理、虚拟环境、多环境管理、版本控制和PyPI 发布。它的设计目标是比 Poetry 更快、更灵活，适用于复杂项目、自动化任务和 CI&#x2F;CD 环境。</li></ol><h3 id="爬取-B-工程视频"><a href="#爬取-B-工程视频" class="headerlink" title="爬取 B 工程视频"></a>爬取 B 工程视频</h3><h4 id="选用-lxml-而不是-BeautifulSoup-的理由"><a href="#选用-lxml-而不是-BeautifulSoup-的理由" class="headerlink" title="选用 lxml 而不是 BeautifulSoup 的理由"></a>选用 lxml 而不是 BeautifulSoup 的理由</h4><ul><li>lxml 支持 XPath 语法, 而 BeautifulSoup 不支持</li><li>lxml 要求所爬取的数据结构规范，所有标签闭合，而 BeautifulSoup 则不一定</li><li>lxml 的解析方式为直接基于 ElementTree 解析，而 BeautifulSoup 则是以 Python 对象方式操作</li><li>lxml.html.fromstring() 和 BeautifulSoup 同样支持 cssselect，不需要另外安装 cssselect 库</li></ul><h4 id="简述-XPath"><a href="#简述-XPath" class="headerlink" title="简述 XPath"></a>简述 XPath</h4><ul><li>XML 和 HTML 都是一种标记语言而不是编程语言</li><li>XML 用于存储、传输数据，而 HTML 专门用于展示网页内容，HTML 文档也叫做网页，HTML 相当于基于 XML 的规范衍生出的一套标记语言，XML 更加通用</li><li>XML 语法严格（要求标签必须闭合，区分大小写），而 HTML 语法松散（标签可以不闭合，不区分大小写）</li><li>XPath 是一门在 XML 文档中定位元素的语言</li></ul><p>给出一些常用的 XPath 表达式：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//book    选择文档中所有 &lt;book&gt; 元素</span><br><span class="line">/bookstore/book    选择根节点 &lt;bookstore&gt; 下的所有 &lt;book&gt; 元素</span><br><span class="line">/bookstore/book[@category]    选择 &lt;bookstore&gt; 下所有带有 category 属性的 &lt;book&gt; 元素</span><br><span class="line">/bookstore/book[@category=&#x27;cooking&#x27;]    选择 &lt;bookstore&gt; 下 category 属性值为 cooking 的 &lt;book&gt; 元素</span><br><span class="line">//* 选择文档中的所有元素</span><br><span class="line">/bookstore/book/title    选择 &lt;bookstore&gt; 下每个 &lt;book&gt; 元素的 &lt;title&gt; 子元素</span><br><span class="line">string_length(/bookstore/book/title)    返回 &lt;title&gt; 元素中字符串长度</span><br><span class="line">sum(/bookstore/book/price)    返回 &lt;price&gt; 元素的和</span><br><span class="line">contains(/bookstore/book/title, &#x27;Python&#x27;)    检查 &lt;title&gt; 元素是否包含字符串 &#x27;Python&#x27;</span><br><span class="line">//title[@lang=&#x27;en&#x27;]    选择所有 lang 属性值为 &#x27;en&#x27; 的 &lt;title&gt; 元素</span><br><span class="line">/bookstore/book[price&gt;30.00]    选择所有 price 元素的值大于 30.00 的 &lt;book&gt; 元素</span><br><span class="line">/bookstore/book/title/text()    返回所有 &lt;title&gt; 元素的文本内容</span><br></pre></td></tr></table></figure><h4 id="lxml-html-和-lxml-etree-HTML-的区别"><a href="#lxml-html-和-lxml-etree-HTML-的区别" class="headerlink" title="lxml.html 和 lxml.etree.HTML 的区别"></a>lxml.html 和 lxml.etree.HTML 的区别</h4><p>两种方法都可以用于解析 HTML，但是 lxml.html 具有自动修正 HTML 结构的特点，返回 lxml.html.HtmlElement 对象，比 ElementTree 提供更多 HTML 相关功能，因此更加适用于网页爬取。</p><h4 id="数据分析–单个视频中的-playinfo-信息"><a href="#数据分析–单个视频中的-playinfo-信息" class="headerlink" title="数据分析–单个视频中的 playinfo 信息"></a>数据分析–单个视频中的 playinfo 信息</h4><p>B站大多单个视频在 开发者工具-&gt;Network-&gt;刷新后的第一条信息（对视频播放信息的请求）-&gt;Response 中 html-&gt;head-&gt;第四个script中保存了 window.<strong>playinfo</strong> 信息，其中包含了视频播放所需的详细信息。<br>在 data-&gt;dash-&gt;video&#x2F;audio 中分别保存了视频和音频的储存地址，包括 baseUrl,base_url,backupUrl(2个),backup_url(2个)</p><h3 id="将-bvget-命令写入系统路径"><a href="#将-bvget-命令写入系统路径" class="headerlink" title="将 bvget 命令写入系统路径"></a>将 <code>bvget</code> 命令写入系统路径</h3><p>可以手动添加到系统路径中：<code>sudo mv bvget.py /usr/local/bin/bvget</code></p><p>也可以使用 <code>setup.py</code> 进行安装</p><p>但是从 PEP 518 开始就有了 <code>pyproject.toml</code> 文件，提供了一个更加现代化、声明式的项目配置</p><p>下面提供一个使用 uv 构建的简单的示例：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[project]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;bvget&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">description</span> = <span class="string">&quot;A simple command line tool to download Bilibili videos&quot;</span></span><br><span class="line"><span class="attr">authors</span> = [&#123;name = <span class="string">&quot;poem&quot;</span>, email = <span class="string">&quot;poem@example.com&quot;</span>&#125;]</span><br><span class="line"><span class="attr">readme</span> = <span class="string">&quot;README.md&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[build-system]</span></span><br><span class="line"><span class="attr">requires</span> = [<span class="string">&quot;setuptools&quot;</span>]</span><br><span class="line"><span class="attr">build-backend</span> = <span class="string">&quot;setuptools.build_meta&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[project.scripts]</span></span><br><span class="line"><span class="attr">bvget</span> = <span class="string">&quot;bvget:main&quot;</span></span><br></pre></td></tr></table></figure><p>对以上内容的解读：</p><p>[project] 定义了项目的基本信息，包括名称、版本、描述、作者、readme等<br>[build-system] 定义构建系统<br>[project.scripts] 定义了项目的命令行工具，这里定义了一个名为 bvget 的命令，对应 bvget.py 中的 main() 函数</p><p>在项目根目录执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uv pip compile --all</span><br><span class="line">uv build</span><br></pre></td></tr></table></figure><p>构建完成后，dist 目录下会生成一个 .whl 文件，.whl 文件是可安装的 Python 包，可以直接使用 pip 安装。.tar.gz 文件是源码包，可以用于源码安装。</p><h3 id="上传至-PyPI"><a href="#上传至-PyPI" class="headerlink" title="上传至 PyPI"></a>上传至 PyPI</h3><p>uv 不支持直接发布 Python 包到 PyPI，但可以借助 twine 工具来实现。<br>首先需要注册一个 PyPI 账户，然后在项目根目录下执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uv add twine</span><br><span class="line">uv publish --username pypi_username --password pypi_password</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">twine upload dist/*</span><br></pre></td></tr></table></figure><p>之后你就可以在任何 Python 环境中安装 bvget 了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install bvget</span><br></pre></td></tr></table></figure><h3 id="Python-导包机制"><a href="#Python-导包机制" class="headerlink" title="Python 导包机制"></a>Python 导包机制</h3><blockquote><p>提醒：环境为 Arch Linux + VSCode<br>Pycharm 有自己的想法（听说是会帮你自动添加路径，如果项目上线就会报各种导入失败的错误）且我没怎么用过，故本文不做讨论<br>为方便后续查看 sys.path 内容，建议添加 from rich import print 来增强可读性<br>所有代码执行的根目录为 project</p></blockquote><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><ul><li><code>package</code>：包，一个包含模块的目录，包含 <code>__init__.py</code> 文件，可以包含子目录</li><li><code>module</code>：模块，一个 <code>.py</code> 文件，包含 Python 代码</li><li><code>__name__</code>：<strong>当前模块名称</strong>（此项与后面解释息息相关）</li><li><code>__package__</code>：<strong>当前模块所在的包名称</strong>（此项与后面解释息息相关）</li><li><code>sys.path</code>：模块搜索路径列表，也即绝对导入搜索路径</li><li><code>__init__.py</code>：模块的初始化文件，在导入包时，会自动执行该文件</li><li><code>__path__</code>：当前模块的搜索路径</li><li><code>__file__</code>：当前模块的文件路径</li><li><code>__loader__</code>：模块的加载器，指向加载该模块的加载器对象</li><li><code>__spec__</code>：存储模块的导入信息（PEP 451）</li><li><code>PEP</code>：Python enhancement proposal，Python 增强建议，是 Python 社区提出的一些改进建议</li><li><code>top-level package</code>：所执行的 package 中最高的一层</li></ul><h4 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a>问题场景</h4><p>有如下目录结构：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">|-project</span><br><span class="line">|    |-sub1</span><br><span class="line">|    |   |-C.py</span><br><span class="line">|    |-sub2</span><br><span class="line">|    |   |-D.py</span><br><span class="line">|    |   |-E.py</span><br><span class="line">|    |-A.py</span><br><span class="line">|    |-B.py</span><br></pre></td></tr></table></figure><p>每个文件中均有一个 <code>_fun()</code> 函数。<br>相对导入基准路径为当前模块所在包。比如 <code>C.py</code> 的基准路径是 <code>sub1</code>，<code>A.py</code> 的基准路径是 <code>project</code>。<br><code>import ..A</code> 这样的隐式相对导入已被 PEP 328 禁止，后文所说的相对导入均指的是显式相对导入。</p><h4 id="问题一：python-filename-py-和-python-m-modulename-的区别"><a href="#问题一：python-filename-py-和-python-m-modulename-的区别" class="headerlink" title="问题一：python filename.py 和 python -m modulename 的区别"></a>问题一：python filename.py 和 python -m modulename 的区别</h4><ul><li>命令1：python sub1&#x2F;C.py</li><li>命令2：python -m sub1.C</li></ul><p>补充说明：</p><ul><li>VSCode 里直接点击小三角运行 Python 文件同命令1原理</li><li>命令2由 PEP 338 规定</li><li>把这个问题放在第一个是为了让读者知道作者是如何运行 Python 文件的，关于命令执行结果的区别，将在问题三中说明</li><li>后文为简化，类似于命令1中的操作均称呼为”命令1”，类似于命令2中的操作均称呼为”命令2”</li></ul><p>在 C.py 中有如下代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> rich <span class="keyword">import</span> <span class="built_in">print</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sys.path)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;C __name__:&quot;</span>, __name__)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;C __package__:&quot;</span>, __package__)</span><br></pre></td></tr></table></figure><p>命令1执行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ python ./sub1/C.py                             -- INSERT --</span><br><span class="line">[</span><br><span class="line">    <span class="string">&#x27;/home/poem/app/vscode/Python/project/sub1&#x27;</span>,</span><br><span class="line">    <span class="comment"># 省略部分</span></span><br><span class="line">]</span><br><span class="line">C __name__: __main__</span><br><span class="line">C __package__: None</span><br></pre></td></tr></table></figure><p>命令2执行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ python -m sub1.C                               -- INSERT --</span><br><span class="line">[</span><br><span class="line">    <span class="string">&#x27;/home/poem/app/vscode/Python/project&#x27;</span>,</span><br><span class="line">    <span class="comment"># 省略部分</span></span><br><span class="line">]</span><br><span class="line">C __name__: __main__</span><br><span class="line">C __package__: sub1</span><br></pre></td></tr></table></figure><ul><li>第一个输出发现我在 VSCode 中项目根目录是 project，而命令1 sys.path 里的路径只有 sub1 目录</li><li>第二个输出表明 C.py 作为顶级脚本被加载，<strong>name</strong> 的值为 <strong>main</strong>，顶级脚本会失去正常名称，而被改为 <strong>main</strong></li><li>第三个输出 <strong>package</strong> 不是当前模块所在的包名称吗？为什么它的值会是 None 呢</li><li>疑惑将在问题三得到解答</li></ul><h4 id="问题二：if-name-‘main‘-语句的作用是什么"><a href="#问题二：if-name-‘main‘-语句的作用是什么" class="headerlink" title="问题二：if name &#x3D;&#x3D; ‘main‘: 语句的作用是什么"></a>问题二：if <strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘: 语句的作用是什么</h4><p>加载 Python 文件有两种方式：作为顶级脚本（一次只能有一个）或者作为模块。</p><ul><li>作为顶级脚本：直接运行 python filename.py 或者 python -m modulename，会将该文件作为顶级脚本加载</li><li>作为模块：当在其他文件中遇到 import 语句时，它会作为模块加载<br>在 C.py 中有如下代码：</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;C __name__:&quot;</span>, __name__)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;C __package__:&quot;</span>, __package__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">c_fun</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I am c_fun&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    c_fun()</span><br></pre></td></tr></table></figure><p>执行 python .&#x2F;sub1&#x2F;C.py 或者 python -m sub1.C 输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python ./sub1/C.py                 -- INSERT --</span><br><span class="line">C __name__: __main__</span><br><span class="line">C __package__: None     <span class="comment"># 后者这里输出 sub1</span></span><br><span class="line">I am c_fun</span><br></pre></td></tr></table></figure><p>接着我们保留 C.py 中代码，C.py 中依然有 if <strong>name</strong> &#x3D;&#x3D; “<strong>main</strong>“: 语句，我们在 A.py 中导入 C.py</p><p>在 A.py 中有如下代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sub1 <span class="keyword">import</span> C</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a_fun</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I am a_fun&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    a_fun()</span><br><span class="line">    C.c_fun()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;A __name__:&quot;</span>, __name__)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;A __package__:&quot;</span>, __package__)</span><br></pre></td></tr></table></figure><p>执行 python .&#x2F;A.py 或者 python -m A 输出结果在最后一行略有不同：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ python ./A.py                      -- INSERT --</span><br><span class="line">C __name__: sub1.C</span><br><span class="line">C __package__: sub1</span><br><span class="line">I am a_fun</span><br><span class="line">I am c_fun</span><br><span class="line">A __name__: __main__</span><br><span class="line">A __package__: <span class="literal">None</span>     <span class="comment"># 如果这里执行的是 `python -m A`，则输出为空</span></span><br></pre></td></tr></table></figure><p>从输出中可以看出 C.py 中的 if <strong>name</strong> &#x3D;&#x3D; “<strong>main</strong>“: 语句未被执行，<strong>name</strong> 的值为 sub1.C。</p><p>所以问题二的答案：if <strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘: 语句的作用是只有当该模块作为顶级脚本时才会执行后面的语句，如果该模块是被 import 进来的，则不会执行。</p><h4 id="问题三：如何在-B-py-中导入-A-py"><a href="#问题三：如何在-B-py-中导入-A-py" class="headerlink" title="问题三：如何在 B.py 中导入 A.py"></a>问题三：如何在 B.py 中导入 A.py</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> A</span><br><span class="line"><span class="comment"># python ./B.py || python -m B</span></span><br><span class="line"><span class="comment"># ImportError: attempted relative import with no known parent package</span></span><br><span class="line"><span class="comment"># . 代表 project 目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cd .. &amp;&amp; python -m project.B</span></span><br><span class="line"><span class="comment"># 成功</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> project <span class="keyword">import</span> A</span><br><span class="line"><span class="comment"># ModuleNotFoundError: No module named &#x27;project&#x27;</span></span><br><span class="line"><span class="comment"># 如果 print(sys.path) 会发现 project 目录是第一条</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cd .. &amp;&amp; python -m project.B</span></span><br><span class="line"><span class="comment"># 成功</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> A</span><br><span class="line"><span class="comment"># 成功</span></span><br></pre></td></tr></table></figure><p>对上面错误做法原因分析：<br>相对导入使用模块的名称（即 <strong>name</strong>）来确定它在包层次结构中的位置。<br>当你使用相对导入时，如 from .. import A，点表示在 package 层次结构中增加一些级别。<br>如果当前模块名称是 project.sub1.C，则 ..A 表示 project.A。<br>要使 from .. import 正常工作，模块名称必须至少包含 import 语句中的点数。</p><p>但是，如果模块名称是 <strong>main</strong>，它的名称里没有点，就好像该模块是顶级模块一样，不管该模块在文件系统上的实际位置如何，其都没有更往上一层的包，因此不能在里面使用 from . import A 这种相对导入。</p><p>理解了问题三错误做法错误的原因，我们再回看问题一。</p><p>命令1执行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ python ./sub1/C.py                             -- INSERT --</span><br><span class="line">[</span><br><span class="line">    <span class="string">&#x27;/home/poem/app/vscode/Python/project/sub1&#x27;</span>,</span><br><span class="line">    <span class="comment"># 省略部分</span></span><br><span class="line">]</span><br><span class="line">C __name__: __main__</span><br><span class="line">C __package__: None</span><br></pre></td></tr></table></figure><p>命令2执行结果：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ python -m sub1.C                               -- INSERT --</span><br><span class="line">[</span><br><span class="line">    <span class="string">&#x27;/home/poem/app/vscode/Python/project&#x27;</span>,</span><br><span class="line">    <span class="comment"># 省略部分</span></span><br><span class="line">]</span><br><span class="line">C __name__: __main__</span><br><span class="line">C __package__: sub1</span><br></pre></td></tr></table></figure><p>从 Python 2.6 开始，用于包解析目的的模块的名称不仅由其 <strong>name</strong> 属性决定，还由 <strong>package</strong> 属性决定。<br>模块的名称实际上是 <strong>package</strong> + ‘.’ + <strong>name</strong>，如果 <strong>package</strong> 是 None，则只是__name__。<br>根据对问题三错误做法的分析，我们知道，两种命令都会让 C.py 作为顶级脚本被加载，这样的话都无法识别上层包，之所以命令2的 <strong>package</strong> 值为 sub1，是因为命令中有 sub1.C 告诉了 Python 加载 C.py 所在的包 sub1。</p><h4 id="问题四：如何在-C-py-中导入-A-py"><a href="#问题四：如何在-C-py-中导入-A-py" class="headerlink" title="问题四：如何在 C.py 中导入 A.py"></a>问题四：如何在 C.py 中导入 A.py</h4><p>常见于 sub1 目录为一个 test 目录<br>以下问题解决办法均只展示部分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .. <span class="keyword">import</span> A</span><br><span class="line"><span class="comment"># 如果你在 project 目录下运行 python ./sub1/C.py</span></span><br><span class="line"><span class="comment"># ImportError: attempted relative import with no known parent package</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cd .. &amp;&amp; python -m project.sub1.C</span></span><br><span class="line"><span class="comment"># 成功</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> ...project <span class="keyword">import</span> A</span><br><span class="line"><span class="comment"># ImportError: attempted relative import with no known parent package</span></span><br><span class="line"><span class="comment"># emmmmm 你应该试试 cd ... &amp;&amp; python -m Python.project.sub1.C</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), <span class="string">&#x27;..&#x27;</span>)))</span><br><span class="line"><span class="comment"># 效果等同于 sys.path.append(&#x27;/home/poem/app/vscode/Python/project&#x27;)</span></span><br><span class="line"><span class="comment"># 或者你在运行时添加 PYTHONPATH=$(pwd) python ./sub1/C.py</span></span><br><span class="line"><span class="keyword">import</span> A</span><br></pre></td></tr></table></figure><h4 id="问题五：如何在-D-py-中导入-C-py"><a href="#问题五：如何在-D-py-中导入-C-py" class="headerlink" title="问题五：如何在 D.py 中导入 C.py"></a>问题五：如何在 D.py 中导入 C.py</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ..sub1 <span class="keyword">import</span> C</span><br><span class="line"><span class="comment"># 如果你在 project 目录下运行 python ./sub2/D.py</span></span><br><span class="line"><span class="comment"># ImportError: attempted relative import with no known parent package</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你在 project 目录下运行 python -m sub2.D</span></span><br><span class="line"><span class="comment"># ModuleNotFoundError: No module named &#x27;project&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cd .. &amp;&amp; python -m project.sub2.D</span></span><br><span class="line"><span class="comment"># 成功</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> project.sub1 <span class="keyword">import</span> C</span><br><span class="line"><span class="comment"># cd .. &amp;&amp; python -m project.sub2.D</span></span><br><span class="line"><span class="comment"># 成功</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sub1 <span class="keyword">import</span> C</span><br><span class="line"><span class="comment"># python -m sub2.D</span></span><br><span class="line"><span class="comment"># 成功</span></span><br></pre></td></tr></table></figure><h4 id="问题六：如何在-E-py-中导入-D-py"><a href="#问题六：如何在-E-py-中导入-D-py" class="headerlink" title="问题六：如何在 E.py 中导入 D.py"></a>问题六：如何在 E.py 中导入 D.py</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> D</span><br><span class="line"><span class="comment"># python ./sub2/E.py</span></span><br><span class="line"><span class="comment"># ImportError: attempted relative import with no known parent package</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># python -m sub2.E</span></span><br><span class="line"><span class="comment"># 成功</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sub2 <span class="keyword">import</span> D</span><br><span class="line"><span class="comment"># python ./sub2/E.py</span></span><br><span class="line"><span class="comment"># ModuleNotFoundError: No module named &#x27;sub2&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># python -m sub2.E</span></span><br><span class="line"><span class="comment"># 成功</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> D</span><br><span class="line"><span class="comment"># 成功</span></span><br></pre></td></tr></table></figure><h4 id="问题七：init-py-文件的作用是什么"><a href="#问题七：init-py-文件的作用是什么" class="headerlink" title="问题七：init.py 文件的作用是什么"></a>问题七：<strong>init</strong>.py 文件的作用是什么</h4><p><code>__init__.py</code> 文件是 Python 包的初始化文件，它会在包被导入时自动执行。<br>但自从 PEP 420 开始（即 Python 3.3），一个目录不需要 <code>__init__.py</code> 文件也可以自动成为包。<br>也就是说一般情况下加不加 <code>__init__.py</code> 文件无所谓。</p><h4 id="推荐使用方式"><a href="#推荐使用方式" class="headerlink" title="推荐使用方式"></a>推荐使用方式</h4><p>通过 <code>sys.path.append()</code> 的方式可以解决燃眉之急，但这种做法并不在大型项目中推荐，因为它会导致项目的依赖关系变得复杂，且不利于代码的维护。<br>同理，使用环境变量 <code>PYTHONPATH</code> 来指定搜索路径也是相当于手动修改 <code>sys.path</code>，也不推荐。</p><p>以下是几种替代方案：</p><p>可编辑安装：<code>setuptools + editable install</code><br>在 <code>project</code> 下创建 <code>setup.py</code> 文件，内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> setup, find_packages</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    name=<span class="string">&quot;bvget&quot;</span>,</span><br><span class="line">    version=<span class="string">&quot;0.1.0&quot;</span>,</span><br><span class="line">    packages=find_packages(),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>运行：<code>pip install -e .</code></p><p>或者使用 uv 进行可编辑安装，进入 project 目录（要求底下有 setup.py 文件或者 pyproject.toml 文件），执行：uv pip install -e .。</p><ul><li>.pth 文件：Python 在启动时会自动读取 site-packages 目录下的 .pth 文件，并将其中的路径添加到 sys.path</li><li>安装为包：将自定义模块打包并安装到 Python 环境中，使其可以被直接导入，该方法在 bvget 项目中已经提供具体做法</li></ul><blockquote><p>参考<br><a href="https://summer24.net9.org/backend/crawler/slide.pdf">清华酒井24爬虫讲义</a><br><a href="https://stackoverflow.com/questions/14132789/relative-imports-for-the-billionth-time">StackOverflow 上关于相对导入的讨论</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;前言：本文使用 uv 进行 Python 环境管理，简述爬取B站视频的核心要点，打包爬取B站视频的命令行工具，并上传至 PyPI，然后自己安装使用&lt;br&gt;针对 Python 的导包机制由浅入深进行讲解，给出七个针对性问题及解答，在文末提出推荐解决方</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Gentoo 安装记录</title>
    <link href="https://kingpoem.github.io/posts/gentoo/"/>
    <id>https://kingpoem.github.io/posts/gentoo/</id>
    <published>2025-05-03T14:29:24.000Z</published>
    <updated>2025-05-03T14:57:31.631Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于-Gentoo-Linux-的安装-选择正确的安装媒介"><a href="#关于-Gentoo-Linux-的安装-选择正确的安装媒介" class="headerlink" title="关于 Gentoo Linux 的安装 &amp;&amp; 选择正确的安装媒介"></a>关于 Gentoo Linux 的安装 &amp;&amp; 选择正确的安装媒介</h3><ul><li>为避免双系统读取 RTC 时间因为时区不一致导致无法加载 Gentoo 内核问题，在 Windows 端设置写入到 RTC 的时区为 UTC：<code>sudo reg add &quot;HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\TimeZoneInformation&quot; /v RealTimeIsUniversal /d 1 /t REG_DWORD /f</code></li><li>关闭 bit locker 加密和 secure boot</li><li>在选择 gentoo 的 <code>boot in normal mode</code> 安装时，会直接进入 grub rescue 环境，退出后再进入 Windows 则显示”你的PIN不可用，单击以重新设置PIN”</li><li>选择 <code>boot in grub2 mode</code></li><li><code>passwd root</code>如果有公网IP，则设置一个强密码</li><li><code>rc-service sshd start</code> 启动ssh服务</li></ul><h3 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h3><ul><li><p><code>net-setup</code>显示<code>enp12s0</code>（以太网接口）和<code>wlp0s20f3</code>（无线局域网）</p></li><li><p>接口命名规则：</p><ul><li><code>p</code>表示设备连接到主板的第几号PCI总线</li><li><code>s</code>表示设备在第几号插槽</li><li><code>f</code>表示该插槽的功能编号为几</li></ul></li><li><p>注意连接协议类型：</p><ul><li><code>open/wep</code>表示开放或者等效有线保密（由于安全性低，现已废弃）</li><li>推荐使用<code>wpa-psk/wpa2-psk</code></li></ul></li><li><p><code>ip link set wlp0s20f3 up</code>显示<code>RFNETLINK answers: Operation not possible due to RF-kill</code> 需要<code>rfkill unblock wifi</code></p></li><li><p>默认dpcp服务没有启动，需要<code>echo &#39;config_eth-=(&quot;dhcp&quot;)&#39; &gt;&gt; /etc/conf.d/net</code>，修改后，重启网络服务<code>/etc/init.d/network restart</code></p></li><li><p><code>ip addr</code>查看本机ip地址，我的是连接无线的，则是wlp0s20f3项inet（表示IPV4协议）后 <code>192.168.43.57/24</code>去掉<code>/24</code>（表示网络部分占用前24位，子网掩码为255.255.255.0）</p></li><li><p>在另一台处于同一个局域网（热点）的电脑远程连接<code>ssh root@192.168.43.57</code>后出现提示输入yes，再输入刚才设置的root密码</p></li></ul><blockquote><p>如果你在接下来的安装中，不小心断开了连接，重新连接继续之前的操作即可 ，注意服务器的ip地址可能会发生变化<br>如果你的 ssh 卡住，可以ps aux | grep ssh 查找进程 PID 并使用 kill -9 PID 杀掉这个 ssh 进程，再重新连接</p></blockquote><h3 id="准备磁盘"><a href="#准备磁盘" class="headerlink" title="准备磁盘"></a>准备磁盘</h3><h4 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h4><ul><li><code>lsblk -f</code>显示有sda nvme0n1 nvme1n1分别对应U盘，加装的固态硬盘，原装的固态硬盘</li><li><code>fdisk /dev/nvme0n1</code><ul><li><code>g</code>创建一个新的GPT磁盘分区表GUID: AEE90FFF-915C-471C-BF7D-4CB8CD08E2D</li><li><code>n</code>创建一个新的分区，按2次enter选择默认的分区号，和分区开始位置，结束位置设置为+1G，如果有显示Do you want to remove the signature则输入<code>yes</code>，<code>t</code>更改磁盘类型为efi</li><li>接下来同样操作建立32G的swap分区</li><li>创建<code>/</code>分区，我分配了300G</li><li>创建<code>/home</code>分区，分配剩下所有空间，文件系统和根分区皆为默认的 Linux filesystem</li></ul></li></ul><h4 id="创建文件系统"><a href="#创建文件系统" class="headerlink" title="创建文件系统"></a>创建文件系统</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkfs.fat -F 32 /dev/nvme0n1p1</span><br><span class="line">mkswap /dev/nvme0n1p2</span><br><span class="line">mkfs.ext4 /dev/nvme0n1p3</span><br><span class="line">mkfs.ext4 /dev/nvme0n1p4</span><br></pre></td></tr></table></figure><h4 id="挂载分区"><a href="#挂载分区" class="headerlink" title="挂载分区"></a>挂载分区</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">swapon /dev/nvme0n1p2</span><br><span class="line"><span class="comment"># 得先有根目录，才能创建下面的目录</span></span><br><span class="line">mount /dev/nvme0n1p3 /mnt/gentoo</span><br><span class="line">mount /dev/nvme0n1p4 /mnt/gentoo/home --<span class="built_in">mkdir</span></span><br><span class="line">mount /dev/nvme0n1p1 /mnt/gentoo/efi --<span class="built_in">mkdir</span></span><br></pre></td></tr></table></figure><p>如果分错了，可以<code>umount /mnt/gentoo/home</code>，中途随时可以使用<code>lsblk -f</code>或者<code>fdisk -l</code>来查看分区状况</p><h3 id="安装Gentoo基础系统"><a href="#安装Gentoo基础系统" class="headerlink" title="安装Gentoo基础系统"></a>安装Gentoo基础系统</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /mnt/gentoo</span><br><span class="line">chronyd -q</span><br><span class="line"><span class="comment"># 同步时间</span></span><br><span class="line">vi /etc/resolv.conf</span><br><span class="line"><span class="comment"># 写入 nameserver 1.1.1.1</span></span><br><span class="line"><span class="comment"># 系统将使用1.1.1.1（Cloudflare提供）作为DNS服务器进行域名解析</span></span><br><span class="line">links https://www.gentoo.org/downloads/mirrors/或者links https://mirrors.ustc.edu.cn/gentoo/</span><br><span class="line"><span class="comment">#选择releases-&gt;amd64-&gt;autobuilds-&gt;current-stage3-amd64-desktop-systemd/ 下载.tar.xz文件</span></span><br><span class="line">tar xpvf stage3-*.tar.xz --xattrs-include=<span class="string">&#x27;*.*&#x27;</span> --numeric-owner</span><br></pre></td></tr></table></figure><ul><li><code>vi /mnt/gentoo/etc/portage/make.conf中COMMON_FLAGS改为-march=native -O2 -pipe</code><br>增加配置如下：</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MAKEOPTS=&quot;-j12&quot;</span><br><span class="line">GENTOO_MIRRORS=&quot;https://mirrors.ustc.edu.cn/gentoo/&quot;</span><br><span class="line">USE=&quot;-gtk -gnome qt6 qt5 gtk3 gtk2 kde alsa X wayland yulkan fcitx dist-kernel dbus vdpau nvenc&quot;</span><br><span class="line">VIDEO_CARDS=&quot;nvidia&quot;</span><br><span class="line">ACCEPT_LICENSE=&quot;@FREE @BINARY-REDISTRIBUTABLE @EULA&quot;</span><br><span class="line">ACCEPT_LICENSE=&quot;en en_US zh zh_CN&quot;</span><br><span class="line">GRUB_PLATFORMS=&quot;efi-64&quot;</span><br></pre></td></tr></table></figure><blockquote><p>上文配置解读：<br>指定12线程并行编译，1job对应内存2G<br>指定 Gentoo 软件包的镜像源<br>USE 标志用于控制软件包的编译选项，-gtk 意为禁用 GTK 支持，vulkan 为图形 API 支持，dist-kernel 为启用分布式内核（Gentoo 提供的预编译内核），dbus 用于进程间通信<br>指定系统使用显卡驱动VIDEO_CARDS<br>指定系统可以接受的软件许可协议<br>设置接受的软件本地化语言<br>指定 GRUB 引导程序的平台目标</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> --dereference /etc/resolv.conf /mnt/gentoo/etc/</span><br><span class="line"><span class="comment"># 将/etc/resolv.conf文件复制到 Gentoo 的根文件系统中，确保在 chroot环境可以解析域名</span></span><br><span class="line">arch-chroot /mnt/gentoo</span><br><span class="line"><span class="comment"># 进入到 Gentoo 的 chroot 环境，为后续配置提供虚拟根目录</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"><span class="comment"># 加载 Gentoo 环境的用户配置文件</span></span><br><span class="line"><span class="built_in">export</span> PS1=<span class="string">&quot;(chroot) <span class="variable">$&#123;PS1&#125;</span>&quot;</span></span><br><span class="line"><span class="comment"># 设置提示符以指示当前处于 chroot 环境中</span></span><br><span class="line">emerge-webrsync</span><br><span class="line"><span class="comment"># 从网站安装 Gentoo ebuild 数据库快照</span></span><br><span class="line">emerge news list</span><br><span class="line"><span class="comment"># 检查是否有新的新闻条目</span></span><br><span class="line">emerge profile list</span><br><span class="line"><span class="comment"># 列出可用的 Gentoo 配置文件</span></span><br><span class="line">emerge profile <span class="built_in">set</span> 27</span><br><span class="line">emerge --ask --oneshot app-portage/cpuid2cpuflags</span><br><span class="line"><span class="comment"># 安装cpuid2cpuflags工具</span></span><br><span class="line">cpuid2cpuflags</span><br><span class="line"><span class="comment"># 输出当前 CPU 支持的指令集</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;*/* <span class="subst">$(cpuid2cpuflags)</span>&quot;</span> &gt; /etc/portage/package.use/00cpu-flags</span><br><span class="line"><span class="comment"># 将 CPU 指令集标志写入 Portage 配置文件，以便为系统的所有软件包启用这些优化</span></span><br><span class="line">emerge --ask --verbose --update --deep --newuse -e @world</span><br><span class="line"><span class="comment"># 重新编译系统中的所有软件包，确保启用了新设置的 USE 标志，同时处理深层依赖项和新增功能，如果在此时你不小心断开了网络连接（比如我第一次安装时连的手机热点，然后中途带着手机出门了），那它中途断开</span></span><br></pre></td></tr></table></figure><h4 id="设置时区"><a href="#设置时区" class="headerlink" title="设置时区"></a>设置时区</h4><ul><li>查看可用时区：<code>ls /usr/share/zoneinfo/...</code><br>OpenRC：</li><li><code>echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone</code></li><li><code>emerge --config sys-libs/timezone-data</code><br>systemd：</li><li><code>ln -sf ../usr/share/zoneinfo/Europe/Brussels /etc/localtime</code>之后当 systemd 运行时，时区和相关设置可以使用 timedatectl 命令设置</li><li><code>emerge vim</code> 我不希望使用nano</li><li><code>vim /etc/locale.gen</code> 生成区域设置<br>添加如下：</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">en_US.UTF-8 UTF-8 # 去掉注释即可</span><br><span class="line">zh_CN.UTF-8 UTF-8</span><br></pre></td></tr></table></figure><ul><li><code>locale-gen</code> 根据 <code>/etc/locale.gen</code> 文件中的设置生成所需的语言环境</li><li><code>locale -a</code> 可以验证当前所选择的 locale 可用</li><li><code>eselect locale list</code> 显示可用目标</li><li><code>eselect locale set 5</code> 选择 zh_CN.utf8</li><li><code>env-update &amp;&amp; source /etc/profile &amp;&amp; export PS1=&quot;(chroot) $&#123;PS1&#125;&quot;</code> 重新加载环境</li><li><code>nano</code> 检测目前语言设置情况</li></ul><h3 id="配置内核"><a href="#配置内核" class="headerlink" title="配置内核"></a>配置内核</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/portage/package.use/installkernel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入：sys-kernel/installkernel dracut grub</span></span><br><span class="line"></span><br><span class="line">emerge --ask sys-kernel/gentoo-kernel</span><br><span class="line"><span class="comment"># 编译内核</span></span><br><span class="line">emerge --ask sys-kernel/linux-firmware</span><br><span class="line"><span class="comment"># 安装固件</span></span><br><span class="line">emerge --ask sys-firmware/sof-firmware</span><br><span class="line">emerge -a sys-firmware/intel-microcode</span><br><span class="line"><span class="comment"># 如果你使用 Intel 的 CPU 的话</span></span><br></pre></td></tr></table></figure><h3 id="配置系统"><a href="#配置系统" class="headerlink" title="配置系统"></a>配置系统</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">emerge fstab</span><br><span class="line">genfstab -U / &gt;&gt; /etc/fstab</span><br><span class="line"><span class="built_in">echo</span> hostname &gt; /etc/hostname</span><br></pre></td></tr></table></figure><h3 id="安装系统工具"><a href="#安装系统工具" class="headerlink" title="安装系统工具"></a>安装系统工具</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">emerge --ask app-admin/sysklogd 安装系统日志</span><br><span class="line">rc-update add sysklogd default</span><br><span class="line">emerge --ask sys-process/cronie 安装守护进程</span><br><span class="line">rc-update add cronie default</span><br><span class="line">emerge --ask sys-apps/mlocate 安装文件索引</span><br><span class="line">emerge --ask app-shells/bash-completion</span><br><span class="line">emerge --ask net-misc/chrony 时间同步</span><br><span class="line">rc-update add chronyd default</span><br><span class="line">emerge -a sys-fs/e2fsprogs sys-fs/dosfstools 安装文件系统工具，对应 ext4 和 VFAT</span><br><span class="line">emerge --ask sys-block/io-scheduler-udev-rules</span><br></pre></td></tr></table></figure><h3 id="配置引导加载程序"><a href="#配置引导加载程序" class="headerlink" title="配置引导加载程序"></a>配置引导加载程序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grub-install --target=x86_64-efi --efi-directory=/efi</span><br><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><h3 id="收尾安装工作"><a href="#收尾安装工作" class="headerlink" title="收尾安装工作"></a>收尾安装工作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">useradd -m -G <span class="built_in">users</span>,wheel,audio,video -s /bin/bash name</span><br><span class="line">passwd name</span><br><span class="line">passwd root</span><br><span class="line">emerge sudo</span><br><span class="line"><span class="built_in">export</span> EDITOR=vim 临时设置编辑器为 vim</span><br><span class="line">visudo</span><br><span class="line">在 etc/sudoers.tmp 文件中查找 root ALL=(ALL:ALL) ALL 并在其下添加 name ALL=(ALL:ALL) ALL 其中，name为你自己刚设置的用户名</span><br><span class="line"><span class="built_in">rm</span> /stage3-*.tar.* 删除安装后的残留文件</span><br><span class="line">emerge openssh</span><br><span class="line">rc-update add sshd default</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h3 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h3><ol><li>问题描述：前期下载用了 OpenRC，Gentoo 启动卡死在了 <code>Setting system clock using the hardware clock [UTC] ...</code> 按任何键都无反应。</li><li>问题排查：</li></ol><ul><li>进入 BIOS 界面，查看系统时间为北京时间</li><li>进入修复环境 <code>mount /dev/nvme1n1p3 /mnt arch-chroot /mnt</code></li><li><code>hwclock --verbose</code> 查看硬件时钟为 UTC 时间，但数值却为 CST 时间</li><li>回顾设置时区部分，执行 <code>emerge --config sys-libs/timezone-data</code> 时，显示 <code>Assuming your /etc/localtime symlink is what you want; skipping update</code></li></ul><ol start="3"><li>问题更大：<br>硬件时间应该是一台电脑只有一个，而系统时间应该可以有多个</li></ol><ul><li>在 Arch 中 <code>timedatectl set-ntp true</code> 启动 <code>System clock synchronized</code> 不对啊，这是在内存中进行的</li><li>进入修复环境 <code>ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code></li><li><code>hwclock --systohc</code></li><li><code>hwclock --verbose</code> 检查硬件时钟正常</li><li><code>reboot</code> 显示问题更大<br>换 <code>systemd</code> 吧</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;关于-Gentoo-Linux-的安装-选择正确的安装媒介&quot;&gt;&lt;a href=&quot;#关于-Gentoo-Linux-的安装-选择正确的安装媒介&quot; class=&quot;headerlink&quot; title=&quot;关于 Gentoo Linux 的安装 &amp;amp;&amp;amp; 选择正</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Windows 更新的链式反应</title>
    <link href="https://kingpoem.github.io/posts/new-blog-md/"/>
    <id>https://kingpoem.github.io/posts/new-blog-md/</id>
    <published>2025-05-03T14:06:14.000Z</published>
    <updated>2025-05-03T14:27:19.443Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Windows-更新干掉了自己"><a href="#Windows-更新干掉了自己" class="headerlink" title="Windows 更新干掉了自己"></a>Windows 更新干掉了自己</h3><p>2024年11月22日，就在我开心使用 Arch+Win11 双系统的时候，一次 Windows 重启更新后，又抽搐般的反复重启了几次。当在 grub 界面选择 Windows 作为启动项时，屏幕上赫然显现下面2行字：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">错误：文件&quot;/efi/Microsoft/Boot/boogmgfw.efi&quot; 未找到</span><br><span class="line">按任意键继续...</span><br></pre></td></tr></table></figure><p>然后就再也进去不 Windows 了。</p><p>我执行了 <code>grub-mkconfig -o /boot/grub/grub.cfg</code> 后，Windows 连在 grub 界面都不显示了。<br>后来找人帮忙，暂时解决了问题。然后，第二天，Windows 又更新了。于是我循着前辈的足迹，又暂时解决了问题。</p><p>首先说明一下我整个的电脑环境：</p><ul><li>华为电脑</li><li>单盘（1T，无法加装硬盘，磁盘分区按先后顺序为 efi1+C+D+E+boot+efi2+&#x2F;+recovery1+recovery2+recovery3 ）</li><li>双系统（Win11 + Arch）</li></ul><p>注意这里的2个 efi 分区，第一个是 Windows 的，第二个是 Arch 的，grub 装在了 efi2 里，后面3个 recovery 是 Windows 的恢复分区，一般来说新电脑会有1个，其他的是 Windows 自己系统升级的产物，真正在工作的只有1个。较新的分区一般会位于磁盘的后部（更高的扇区），原厂或系统安装的分区通常在磁盘的前部（可以通过在 powershell 中使用reagentc &#x2F;info查看当前使用的是哪个恢复分区）。</p><p>通过 <code>efibootmgr</code> 查看 efi 的启动顺序，会发现没有 Windows 的引导，所以可以自己手动创建一条 Windows 的引导，然后通过 <code>efibootmgr -o</code> 可以自定义启动顺序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 手动创建 Windows 引导项</span></span><br><span class="line">sudo efibootmgr --disk /dev/nvme0n1 --part 1 --create --label <span class="string">&quot;Windows(Custom)&quot;</span> --loader <span class="string">&quot;\\EFI\\Microsoft\\Boot\\bootmgr.efi&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置下次启动项</span></span><br><span class="line">sudo efibootmgr --bootnext 0002</span><br><span class="line">systemctl reboot</span><br></pre></td></tr></table></figure><p>常用命令备忘：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除第一条记录</span></span><br><span class="line">sudo efibootmgr -b 0001 -B</span><br><span class="line"><span class="comment"># 挂载查看分区内容</span></span><br><span class="line">mount /dev/nvme0n1p1 /mnt</span><br></pre></td></tr></table></figure><p>efi 文件在 Arch 中的参考路径：<code>/boot/EFI/ARCH/grubx64.efi</code></p><h3 id="Windows-更新干掉了-Arch-和自己"><a href="#Windows-更新干掉了-Arch-和自己" class="headerlink" title="Windows 更新干掉了 Arch 和自己"></a>Windows 更新干掉了 Arch 和自己</h3><p>对于 Arch 的存在，Windows 是不能够容忍的。在第一阶段，他自己更新把自己干掉了，在第二阶段，他更新的攻击目标转向了 Arch。他将 Arch 的引导从 grub 里删除了，无论怎么启动都会是 Windows。刚开始，我通过 UEFI 界面的调节还能暂时解决问题。</p><p>到后来，我在 UEFI 中设置 Windows 先，会直接进入 grub 的修复环境，桌面显示如下文字：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error: unknown filesystem</span><br><span class="line">Entering rescue mode...</span><br><span class="line">grub rescue&gt;</span><br></pre></td></tr></table></figure><p>修复步骤：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">error: unknown filesystem</span><br><span class="line">Entering rescue mode...</span><br><span class="line">grub rescue&gt; ls // 查看所有磁盘分区</span><br><span class="line">grub rescue&gt; ls (hd0,gpt7) // 查看gpt7分区的类型，我们应该找到 efi 分区所在地，其他的磁盘分区大多会显示为 unknown filesystem</span><br><span class="line">grub rescue&gt; set root=(hd0,gpt7)</span><br><span class="line">grub rescue&gt; set prefix=(hd0,gpt7)/grub</span><br><span class="line">grub rescue&gt; indmod normal</span><br><span class="line">grub rescue&gt; normal // 然后就可以进入正常的 grub 引导界面啦</span><br></pre></td></tr></table></figure><p>但是，在 grub 界面，如果选择 Windows，又会显示找不到 efi，选择 Arch 则可以正常进入。</p><p>如果我在 UEFI 中设置 Arch 先，那么会直接进入 Windows。</p><p>也就是说，Arch 在用原本应该是 Windows 的 efi，Windows 在用原本是 Arch 的 efi！</p><p>那么为什么 Arch 能用 Windows 的 efi，答案就是不能用，所以会显示 unknown filesystem，要通过在 grub 的修复环境中选择 Arch 的 efi 才能进去。</p><h3 id="毁灭与新生"><a href="#毁灭与新生" class="headerlink" title="毁灭与新生"></a>毁灭与新生</h3><p>于是，重装系统！</p><p>刚开始还是想挑战高难度一点的 Gentoo 的，但是由于挂载的问题，第一次安装失败 。万念俱灰之下，又迫切需要一台能用的电脑，于是选择了单系统 Arch。还是 Arch 最平衡，不像 Gentoo 那样安装时间要特别长，又不像 deepin 和 Ubuntu 那样安装特别简单。</p><p>重装系统能解决许多历史遗留问题，但由于没有做好备份工作（主要是某些文件在项目中需要加入 .gitignore，在使用 Github 进行备份时就没有包含进去，包括项目中的 csv 原始数据，博客的 themes&#x2F;butterfly 下的配置文件，按道理说这个目录下的配置文件应该放在博客根目录下，但是为什么我没有呢？也是历史遗留问题！），我丢失了很多东西。因为丢失了博客的配置文件，而我又不想再花大把时间进行博客的配置，于是新开了这个博客，并选择了一套开箱即用的主题，并调整了一下自己写作博客的思路。我想主要以文字为主（图片的路径问题在 butterfly 下也已经恼到我了，而且图片多了的话博客加载速度也慢），人类原创，融入英文写作。</p><p>但是我还是需要 Windows 的，正值数学实验和金工实习期间，需要 Matlab 和 3D打印的一些建模和打印软件（SolidWorks 和 Wiiboox，这俩玩意也是异常的难安装），这些在 Arch 下都没有什么特别好的替代品，只能选择在 Oracle VirtualBox 中创建一个 Win11 的虚拟机（Matlab用网页版）。中间还出了一个小问题，因为在选择新建电脑时选择了自动安装，导致没有超级管理员，后面无论是从浏览器还是从应用商店里下载的QQ或者微信都无法安装，当然，终端管理员也无法打开。解决方法就是重装，新建电脑时不要选择自动安装。</p><h3 id="新建博客"><a href="#新建博客" class="headerlink" title="新建博客"></a>新建博客</h3><p>在看了各种博客框架后，我依然选择了 Hexo，并解决了包括 npm 全局安装导致的 root 权限等一系列历史遗留问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 局部安装 hexo</span></span><br><span class="line">npm install hexo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 环境变量配置（添加到 ~/.zshrc）</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$HOME</span>/app/hexo/node_modules/.bin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置别名</span></span><br><span class="line"><span class="built_in">alias</span> hexo_=<span class="string">&quot;cd blog &amp;&amp; hexo clean &amp;&amp; hexo generate &amp;&amp; hexo server&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Windows-更新干掉了自己&quot;&gt;&lt;a href=&quot;#Windows-更新干掉了自己&quot; class=&quot;headerlink&quot; title=&quot;Windows 更新干掉了自己&quot;&gt;&lt;/a&gt;Windows 更新干掉了自己&lt;/h3&gt;&lt;p&gt;2024年11月22日，就在我开心使</summary>
      
    
    
    
    
  </entry>
  
</feed>
